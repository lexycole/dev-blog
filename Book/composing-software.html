
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    
    <title>dev-blog</title>
    <link rel="stylesheet" href="/dev-blog/styles/global.css">
    <link rel="stylesheet" href="/dev-blog/highlight/default.min.css">
  </head>
  <body>
    <header>
      <nav>
        <a href="/dev-blog">dev-blog</a>
      </nav>
    </header>
    <article>
      <h1>Composing Software</h1>
<blockquote>
<p><a href="https://www.amazon.com/Composing-Software-Exploration-Programming-Composition/dp/1661212565">Composing Software</a>를 읽고 정리한 글</p>
</blockquote>
<h2>JS 와 FP</h2>
<h3>JS의 FP 특성</h3>
<p><strong>First Class Function</strong></p>
<ul>
<li>JS는 함수를 인자로 넘기거나, 함수를 반환하거나, 함수를 변수에 할당하는 등 함수를 데이터 값으로 다룰 수 있다. 덕분에, High-Order-Function, Partial Application, Curry, Composition을 활용할 수 있다.</li>
</ul>
<p><strong>익명 함수와 간결한 람다 문법</strong></p>
<ul>
<li>간결한 람다 문법으로 High-Order-Function 을 활용하기 쉽다.</li>
</ul>
<p><strong>Closure</strong></p>
<ul>
<li>클로저는 함수를 렉시컬 환경과 함께 생성하는 것이다. 클로저를 활용해 고정된 인자를 가진 함수를 만들어 낼 수 있다.</li>
</ul>
<h3>FP언어에 비해 JS에 부족한 FP 특성</h3>
<p><strong>Purity (순수성)</strong></p>
<ul>
<li>일부 FP 언어에서는 순수성이 강제된다.</li>
<li>JS 에서 순수성은 컨벤션을 통해 보장해야 하기 때문에 쉽게 순수성이 깨질 수 있다.</li>
</ul>
<p><strong>Immutability (불변성)</strong></p>
<ul>
<li>일부 FP 언어에서는 Mutation 이 불가능하다. Mutation을 피하기 위해 매번 새로운 데이터를 생성해 내는데, FP 언어레벨에서 Trie 형태의 데이터를 이용해 효율적인 Immutability 데이터를 다룰 수 있도록 보장한다.</li>
<li>JS 에서는 기본적으로는 이런 특징을 제공하지 않는다. 이를 도와주는 <a href="https://github.com/immutable-js/immutable-js">Immutable.js</a> 와 같은 라이브러리가 존재한다.</li>
</ul>
<p><strong>Recursion (재귀)</strong></p>
<ul>
<li>일부 FP 언어에서는 반복문 대신 재귀를 사용하도록 강제한다.</li>
<li>JS에서도 재귀 사용이 가능하지만 꼬리 재귀 최적화와 같이 언어적으로 스택과 프레임을 재사용하도록 하는 효율적인 재귀 사용 지원이 부족하다.</li>
<li>꼬리 재귀 최적화 없이 많은 재귀문을 사용하면 스택오버플로우의 위험이 있다.</li>
<li>일부 최신 브라우저에서는 꼬리 재귀 최적화를 지원한다.</li>
</ul>

    </article>
  </body>
</html>
