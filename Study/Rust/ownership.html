
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    
    <title>dev-blog</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="48x48" href="favicon/favicon-48x48.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">
    <link rel="icon" href="favicon/favicon.ico">
    <link rel="stylesheet" href="/dev-blog/styles/global.css">
    <link rel="stylesheet" href="/dev-blog/highlight/default.min.css">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZBZX7LMVNE"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-ZBZX7LMVNE');
    </script>
  </head>
  <body>
    
  <header>
    <nav>
      <a href="/dev-blog" class="logo">dev-blog</a>
    </nav>
  </header>
  
    <article>
      <div class="container">
        <div class="content">
          <h1 id="소유권-ownership">소유권 (Ownership)</h1>
<p>소유권은 Rust의 특징중 하나인데 가비지 컬렉터없이 메모리를 안정적으로 사용할 수 있도록 보장해준다.</p>
<h2 id="소유권-규칙">소유권 규칙</h2>
<p>아래는 Rust 소유권과 관련된 규칙이다.</p>
<ul>
<li>Rust 의 각 값은 값을 소유한 <code>owner</code> 변수가 존재한다.</li>
<li>특정 시점에 값의 <code>owner</code> 는 단 하나 뿐이다.</li>
<li><code>owner</code>가 스코프를 벗어나면 그 값은 제거된다.</li>
</ul>
<h3 id="move"><code>move</code></h3>
<pre><code class="hljs language-rs"><span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;
<span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">y</span> = x;</code></pre>
<p>위 코드를 보면 <code>x</code> 에 <code>5</code> 가 할당되고, <code>x</code>의 값이 복사되어 <code>y</code> 에 할당된다고 추론할 수 있다. 정수와 같이 간단한 데이터는 실제로 추론한 것 처럼 동작한다.</p>
<pre><code class="hljs language-rs"><span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s1</span> = String::<span class="hljs-title hljs-function hljs-invoke">from</span>(<span class="hljs-string">"hello"</span>);
<span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s2</span> = s1;</code></pre>
<p>하지만 <code>String</code> 과 같이 복잡한 데이터는 정수와 같이 동작하지 않는다.
<code>String</code> 을 할당받은 변수는 문자열 값이 아니라 해당 데이터가 저장된 메모리 포인터를 가지고 있다.</p>
<pre><code class="hljs language-rs"><span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s1</span> = String::<span class="hljs-title hljs-function hljs-invoke">from</span>(<span class="hljs-string">"hello"</span>);
<span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s2</span> = s1;

<span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}, world!"</span>, s1); <span class="hljs-comment">// error[E0382]: borrow of moved value: `s1</span></code></pre>
<p>Rust에서는 메모리 안정성을 위해서 <code>let s2 = s1</code> 이 실행된 이후 <code>s1</code>은 더이상 사용할 수 없게 된다. 이런 방식으로 Rust 는 <code>s1</code> 의 메모리를 해제하지 않아도 된다. (<code>s2</code> 만 관리하면 됨)</p>
<p>이런 식으로 포인터를 가진 변수를 다른 변수에 할당하면 <code>shallow copy</code> 가 일어나는데 기존에 변수는 사용할 수 없기 때문에, 이런 동작을 Rust 에서는 <code>move</code> 라고 한다.</p>
<h3 id="clone"><code>clone</code></h3>
<p>만약 <code>String</code> 데이터를 <code>deep copy</code> 하고 싶다면 <code>clone</code> 메서드를 사용할 수 있다.</p>
<pre><code class="hljs language-rs"><span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s1</span> = String::<span class="hljs-title hljs-function hljs-invoke">from</span>(<span class="hljs-string">"hello"</span>);
<span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s2</span> = s1.<span class="hljs-title hljs-function hljs-invoke">clone</span>();

<span class="hljs-built_in">println!</span>(<span class="hljs-string">"s1 = {}, s2 = {}"</span>, s1, s2);</code></pre>
<h3 id="stack-only-data-copy"><code>stack only data: copy</code></h3>
<p><code>u32</code>, <code>bool</code>, <code>f64</code>... 등과 같이 컴파일러가 데이터 크기를 알고있고 스택에 올라가는 데이터는 단순하게 복사가 일어난다.</p>
<pre><code class="hljs language-rs"><span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;
<span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">y</span> = x;

<span class="hljs-built_in">println!</span>(<span class="hljs-string">"x = {}, y = {}"</span>, x, y);</code></pre>
<h2 id="소유권과-함수">소유권과 함수</h2>
<p>함수에 값을 넘겨주는 것은 변수에 값을 할당하는 것과 유사하다. 함수로 넘겨진 변수는 <code>move</code> 혹은 <code>copy</code> 가 발생한다.</p>
<pre><code class="hljs language-rs"><span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = String::<span class="hljs-title hljs-function hljs-invoke">from</span>(<span class="hljs-string">"hello"</span>);

    <span class="hljs-title hljs-function hljs-invoke">takes_ownership</span>(s);  <span class="hljs-comment">// s 의 값이 함수로 `move` 된다.</span>
                         <span class="hljs-comment">// 때문에 s 는 더이상 유효하지 않다.</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;

    <span class="hljs-title hljs-function hljs-invoke">makes_copy</span>(x);  <span class="hljs-comment">// x 는 함수로 `copy` 된다.</span>
                    <span class="hljs-comment">// 때문에 이후에도 x 는 유효하다.</span>
}

<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">takes_ownership</span>(some_string: <span class="hljs-type">String</span>) {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, some_string);
} <span class="hljs-comment">// some_string 이 가르키는 메모리는 해제된다 (drop)</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">makes_copy</span>(some_integer: <span class="hljs-type">i32</span>) {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, some_integer);
} <span class="hljs-comment">// 특별한 메모리 해제가 발생하진 않는다.</span></code></pre>
<h3 id="반환값과-스코프">반환값과 스코프</h3>
<p>값의 반환에도 소유권이동이 발생한다.</p>
<pre><code class="hljs language-rs"><span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s1</span> = <span class="hljs-title hljs-function hljs-invoke">gives_ownership</span>(); <span class="hljs-comment">// 반환 값의 소유권이 s1 으로 넘어온다.</span>

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s2</span> = String::<span class="hljs-title hljs-function hljs-invoke">from</span>(<span class="hljs-string">"hello"</span>);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s3</span> = <span class="hljs-title hljs-function hljs-invoke">takes_and_gives_back</span>(s2);  <span class="hljs-comment">// s2 의 소유권을 넘겨주고</span>
                                        <span class="hljs-comment">// 반환 값의 소유권을 s3에 넘겨받는다</span>
} <span class="hljs-comment">// s3 은 스코프를 벗어났기 때문에 메모리가 해제된다 (drop)</span>
  <span class="hljs-comment">// s2 는 소유권이 넘겨갔기 때문에 아무일도 일어나지 않는다.</span>
  <span class="hljs-comment">// s1 은 스코프를 벗어났기 때문에 메모리가 해제된다 (drop)</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">gives_ownership</span>() <span class="hljs-punctuation">-></span> <span class="hljs-type">String</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">some_string</span> = String::<span class="hljs-title hljs-function hljs-invoke">from</span>(<span class="hljs-string">"yours"</span>);
    some_string
}

<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">takes_and_gives_back</span>(a_string: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-></span> <span class="hljs-type">String</span> {
    a_string
}</code></pre>

        </div>
        
  <nav class="toc-heading">
    
<ul>
<li><a href="#소유권-규칙"> 소유권 규칙</a>
<ul>
<li><a href="#move"> `move`</a></li>
<li><a href="#clone"> `clone`</a></li>
<li><a href="#stack-only-data-copy"> `stack only data: copy`</a></li>

</ul>
</li>
<li><a href="#소유권과-함수"> 소유권과 함수</a>
<ul>
<li><a href="#반환값과-스코프"> 반환값과 스코프</a></li>

  </nav>
  
      </div>
    </article>
  </body>
</html>
