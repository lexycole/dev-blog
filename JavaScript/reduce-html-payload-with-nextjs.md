# Next.js에서 HTML 페이로드 줄이기 (사례 연구)

**빠른 요약**

> 이 글은 Bookaway의 랜딩 페이지 성능에 대한 사례 연구를 다룹니다.
Next.js 페이지로 전달되는 props를 어떻게 잘 관리해서 로딩 시간과 웹 바이탈을 향상시킬 수 있었는지 알아보겠습니다.

여러분이 무슨 생각인지 알고 있습니다.
자바스크립트 의존성을 줄이고 클라이언트에 전송되는 번들 크기를 줄이는 것을 다룬 다른 글이 있습니다.
하지만 이 글은 조금 다르다는 걸 약속합니다.

이 글은 [Bookaway](https://www.bookaway.com/ko)가 직면한 몇 가지 상황과 우리가(여행 업계의 한 회사로서) 전송되는 HTML을 더 작게 만들어 페이지를 최적화한 것에 대한 것입니다.
작은 HTML은 구글이 긴 문자열을 다운로드하고 처리하는 시간이 줄어든다는 것을 뜻합니다.

보통, HTML 코드 크기는 문제가 되진 않는데, 데이터가 많지 않은 작은 페이지나 SEO를 지향하지 않는 페이지에서는 더욱 그렇습니다.
하지만, 우리는 데이터 베이스가 많은 양의 데이터를 저장하고 있고 수천 개의 랜딩 페이지를 제공해야 하기 때문에 상황이 달랐습니다.

왜 이 정도의 규모가 필요한지 의아할 텐데요.
(Covid-19 이전에) Bookaway는 1,500개의 사업자와 협력하여 63개국에서 2만 개 이상의 서비스를 제공하고 있으며 매년 200%씩 성장했습니다.
2019년에는 연간 50만 장의 티켓을 판매했기 때문에 운영이 복잡했으며 랜딩 페이지를 통해 이를 매력적이고 빠르게 선보여야 했습니다.
구글 봇(SEO)과 실제 고객 모두에게 말이죠.

이 글에서는 다음과 같은 내용을 다룹니다.

- HTML 크기가 너무 크다는 것을 어떻게 알게 되었는지;
- 어떻게 그 크기를 줄였는지;
- 이 과정의 이점(즉, 아키텍처 개선, 코드 구성 개선, 구글이 수만 개의 랜딩 페이지를 인덱싱할 수 있도록 올바른 작업 제공, 클라이언트에 더 적은 바이트를 제공 - 특히 연결 속도가 느린 사용자에게 적합한).

하지만 가장 먼저, 속도 개선에 중요성에 대해 이야기해 봅시다.

## 왜 속도 개선이 SEO에 필요할까요?

"[Web Vitals](https://web.dev/vitals/)"을 볼텐데요, 특히 [LCP](https://web.dev/lcp/)를 살펴 보겠습니다.

> "Largest Contentful Paint(LCP)는 페이지의 메인 콘텐츠가 로드되었을 가능성이 있을 때 페이지 로드 타임라인에 해당 시점을 표시하므로 사용자가 [감지하는 로드 속도](https://web.dev/user-centric-performance-metrics/#types-of-metrics)를 측정할 수 있는 중요한 사용자 중심 지표입니다. LCP가 빠르면 사용자가 해당 페이지를 [사용할 수 있다](https://web.dev/user-centric-performance-metrics/#questions)고 인지하는 데 도움이 됩니다.

주요 목표는 LPC를 가능한 작게하는 것입니다.
LPC를 작게하는 방법 중 하나는 사용자가 가능한 작은 HTML을 다운로드하도록 하는 것입니다.
이렇게 하면, 사용자는 가장 큰 컨텐츠를 그리는 작업을 최대한 빨리 시작할 수 있습니다.

LCP는 사용자 중심의 지표이지만, 이를 줄이는 것은 구글 봇에도 큰 도움이 될 것입니다.

> 웹은 시용 가능한 모든 URL을 탐색하고 인덱싱 하는 구글의 능력을 초과하는 거의 무한한 공간입니다.
따라서 구글 봇이 어떤 사이트를 탐색하는 데 사용할 수 있는 시간에 한계가 있습니다.
사이트를 탐색하기 위한 구글의 시간과 자원의 양은 일반적으로 사이트의 크롤링 예산이라고 합니다. - "[Advanced SEO](https://developers.google.com/search/docs/advanced/crawling/large-site-managing-crawl-budget)", 구글 검색 센터 문서

크롤링 예산을 개선하는 가장 좋은 기술적 방법 중 하나는 구글이 더 짧은 시간 내에 더 많은 작업을 할 수 있도록 돕는 것입니다.

> **Q**: "사이트 속도가 크롤링 예산에 영향을 줍니까? 에러는 어떤가요?"
>
> **A**: 사이트를 더 빠르게 만들면 사용자 경험이 개선되는 동시에 크롤링 속도도 향상됩니다.
> 구글봇에게 있어 빠른 사이트는 서버 상태가 양호하다는 신호이고 동일한 수의 커넥션으로 더 많은 컨텐츠를 가져올 수 있습니다.

정리하면, 구글봇과 Bookaway 클라이언트는 같은 목표를 가지고 있습니다 - 둘 다 컨텐츠를 빠르게 전달받기를 원합니다. 우리의 데이터베이스는 모든 페이지에 대해 많은 양의 데이터를 포함하고 있기 때문에, 우리는 이를 효율적으로 집계해서 고객에게는 작고 얇게 보내야 합니다.

우리가 개선할 수 있는 방법에 대한 조서로 HTML 에 큰 JSON 이 내장되어 있어 HTML 을 뚱뚱하게 만든다는 것을 발견했습니다.
이 경우, React Hydration 을 이해해야 합니다.

## 리액트 Hydration: 왜 HTML에 JSON이 있나요?

이는 서버 사이드 렌더링이 리액트와 Next.js에서 동작하는 방식 때문입니다.

1. 요청이 서버에 도착하면 - 데이터 묶음을 기본으로 HTML을 생성해야 합니다. 데이터 묶음은 `getServerSideProps`를 통해 반환된 객체입니다.
2. 리액트가 데이터를 전달받습니다. 이제 서버에서 작동하기 시작합니다. HTML을 생성해 전송합니다.
3. 클라이언트가 HTML을 전달받으면, 즉시 눈앞에 그려집니다 그 동안, 리액트 자바스크립트가 다운로드되고 실행됩니다.
4. 자바스크립트 실행이 끝나면, 리액트가 클라이언트에서 다시 실행됩니다. HTML을 다시 빌드라고 이벤트 리스너를 부착합니다. 이 작용을 [hydration](https://reactjs.org/docs/react-dom.html#hydrate)이라고  합니다.
5. 리액트가 hydration 과정을 위해 HTML을 다시 빌드할 때, 서버에서 사용되는 것과 동일한 데이터 묶음이 필요합니다. (1. 참고)
6. 이 데이터 묶음은 ID가 `__NEXT_DATA__`인 스크립트 태그 안에 JSON을 삽입되어 사용될 수 있게 됩니다.


## 정확히 어떤 페이지에 대해 이야기하고 있나요?

검색 엔진에서 우리 제품을 홍보해야 하기 때문에 랜딩 페이지의 필요성이 대두되었습니다.
사람들은 보통 특정 버스 노선의 이름을 검색하지 않고, "방콕에서 파타야까지 어떻게 가나요" 처럼 검색합니다.
지금까지 우리는 이런 질문에 답하는 네가지 유형의 랜딩 페이지를 만들었습니다:

1. A 도시에서 B 도시

    A 도시의 역에서 B 도시의 역까지 이어져 있는 모든 노선. (예: [방콕에서 파타야까지](https://www.bookaway.com/routes/thailand/bangkok-to-pattaya))

2. 도시

    특정 도시를 지나는 모든 노선. (예: [칸쿤](https://www.bookaway.com/routes/mexico/cancun))

3. 나라

    특정 나라를 지나는 모든 노선 (예: [이탈리아](https://www.bookaway.com/routes/italy))

4. 역

    특정 역을 지나는 모든 노선 (예: [하노이 공항](https://www.bookaway.com/routes/vietnam/hanoi/hanoi-airport))

## 이제, 아키텍처에 대해 살펴보겠습니다.

지금 말씀드린 랜딩 페이지를 지원하는 인프라에 대해 단순하고 고-수준으로 살펴보겠습니다.
흥미로운 부분은 4번과 5번입니다.
여기에 낭비되는 부분이 있습니다.


### 과정의 주요 이점

1. a
2. a
3. a
4. a