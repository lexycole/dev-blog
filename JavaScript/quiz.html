<h2>Q-1. 다음 코드의 결과는 무엇일까요?</h2>
<pre><code class="language-js">const foo = {
    name: 'Foo'
}
const bar = Object.create(foo);
delete bar.name;

console.log(bar.name); // ?
</code></pre>
<details><summary>Q-1 답안 보기</summary>
<p>
<h3>정답: "Foo"</h3>
<h3>해설:</h3>
<p>결과를 이해하기 위해서는 <strong>1. delete</strong>와 <strong>2 Object.create</strong> 를 이해해야합니다.</p>
<h4>1. delete</h4>
<p><code>delete</code> 연산자는 대상 객체의 <strong>고유 프로퍼티를 삭제</strong>합니다.</p>
<pre><code class="language-js">const obj = {
    prop1: 'prop1', 
    prop2: 'prop2',
}
delete obj.prop1;
console.log(obk); // {prop2: "prop2"}
</code></pre>
<p><strong>교유 프로퍼티를 삭제</strong> 한다는 뜻은 프로토 타입 체인으로 연결된 프로퍼티는 제거하지 않는다는 걸 의미합니다.</p>
<pre><code class="language-js">const obj ={
    toString: () => 'shadowed',
}
console.log(obj.toString()); // shadowed
delete obj.toString;
console.log(obj.toString()); // [object Object]
</code></pre>
<h4>2. Object.create</h4>
<p><code>Object.create</code> 는 첫 번째 인자를 프로토타입으로 하는 객체를 생성합니다.</p>
<p>즉 프로터타입 체이닝을 통해서 인자의 프로퍼티에 접근할 수 있지만, 그 값은 생성된 객체의 고유한 프로퍼티가 아닙니다.</p>
<pre><code class="language-js">const obj = {
    prop1: 'prop1'
}
const newObj = Object.create(obj);

newObj.prop1; // 'prop1'
newObj.hasOwnProperty('prop1'); // false
</code></pre>
<h4>문제 해설</h4>
<p><code>Object.create</code> 로 <strong>foo</strong> 를 프로토타입으로 한 <strong>bar</strong> 객체를 생성합니다.</p>
<pre><code class="language-js">const foo = {
    name: 'Foo'
};
const bar = Object.create(foo); 
</code></pre>
<p><code>delete</code> 로 <strong>bar</strong> 의 고유 프로퍼티 <strong>name</strong> 을 제거합니다. 하지만 <strong>bar</strong> 에는 <strong>name</strong> 프로퍼티가 없기 때문에 아무 변화도 일어나지 않습니다.</p>
<pre><code class="language-js">delete bar.name
</code></pre>
<p><code>bar.name</code>에 접근하면 프로토타입 체이닝을 통해 <strong>foo</strong>의 <strong>name</strong> 으로 접근됩니다.</p>
<pre><code class="language-js">console.log(bar.name);  // 'Foo'
</code></pre>
</p>
</details>
