
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>dev-blog</title>
    <link rel="stylesheet" href="/dev-blog/styles/global.css">
    <link rel="stylesheet" href="/dev-blog/highlight/default.min.css">
  </head>
  <body>
    <header>
      <nav>
        <a href="/dev-blog">dev-blog</a>
      </nav>
    </header>
    <article>
      <h1>코딩 컨벤션 업무를 하며 알게 된 것들 - 2</h1>
<p>이전 글에 이어서 Javascript 코딩 컨벤션 관련 업무를 하며 <a href="https://eslint.org/">ESLint</a> 규칙을 통해 알게 된 점을 정리해 보았습니다.</p>
<ul>
<li><strong>1. no-prototype-builtins</strong></li>
<li><strong>2. no-return-await</strong></li>
<li><strong>3. comma-dangle</strong></li>
</ul>
<h2>1. no-prototype-builtins</h2>
<p><a href="https://eslint.org/docs/rules/no-prototype-builtins">ESLint: no-prototype-builtins</a></p>
<p>이 규칙은 Object.prototype의 builtin으로 제공되는 메서드를 객체에서 직접 호출하지 않도록 하는 규칙입니다.</p>
<p>Object.prototype의 builtin 메서드는 <code>hasOwnProperty</code>, <code>isPrototypeOf</code> 등이 있습니다. 이 메서드를 호출하는 방법은 다음과 같은 방법이 있습니다.</p>
<ul>
<li>(1) 객체에서 직접 호출하는 방법</li>
<li>(2) Object.prototype을 이용하여 호출하는 방법</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'joah'</span>,
}

<span class="hljs-comment">//  (1) 객체에서 직접 호출</span>
obj.<span class="hljs-title hljs-function">hasOwnProperty</span>(<span class="hljs-string">'name'</span>); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// (2) Object.prototype을 이용해 호출</span>
<span class="hljs-title hljs-class">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title hljs-function">call</span>(obj, <span class="hljs-string">'name'</span>); <span class="hljs-comment">// true</span></code></pre>
<p>no-prototype-builtins 규칙을 통해 객체에서 builtin 메서드를 직접 호출하지 않도록 하는 이유는 다음과 같습니다.</p>
<ol>
<li>
<p><strong>Object.create(null)</strong></p>
<p>ECMAScript 5.1에서 추가된 Object.create 메서드에 null을 인자로 주어 객체를 생성하게 되면 Object.prototype을 상속받지 않게 됩니다.</p>
<pre><code class="hljs language-js"> <span class="hljs-keyword">const</span> obj = <span class="hljs-title hljs-class">Object</span>.<span class="hljs-title hljs-function">create</span>(<span class="hljs-literal">null</span>);
 obj.<span class="hljs-property">name</span> = <span class="hljs-string">'joah'</span>;

 obj.<span class="hljs-property">hasOwnProperty</span>; <span class="hljs-comment">// undefined</span>
 obj.<span class="hljs-title hljs-function">hasOwnProperty</span>(<span class="hljs-string">'name'</span>); <span class="hljs-comment">// Uncaught TypeError</span>
 <span class="hljs-title hljs-class">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title hljs-function">call</span>(obj, <span class="hljs-string">'name'</span>); <span class="hljs-comment">// true</span></code></pre>
<p>따라서 위와 같이 Object.create(null)로 만든 객체에서 builtin 메서드를 직접 호출하게 된다면 에러를 발생시킵니다.</p>
</li>
<li>
<p><strong>속성이 builtin 메서드를 감추는 경우</strong></p>
<p>객체에 builtin으로 제공되는 메서드와 같은 이름의 키를 객체가 가지고 있다면 예상한 대로 동작하지 않을 수 있습니다.</p>
<pre><code class="hljs language-js"> <span class="hljs-keyword">const</span> badJSON = {
   <span class="hljs-string">'hasOwnProperty'</span>: <span class="hljs-string">'1'</span>,
   <span class="hljs-string">'name'</span>: <span class="hljs-string">'joah'</span>
 }

 <span class="hljs-comment">// ...</span>

 badJSON.<span class="hljs-title hljs-function">hasOwnProperty</span>(<span class="hljs-string">'name'</span>); <span class="hljs-comment">// Uncaught TypeError</span>
 <span class="hljs-title hljs-class">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title hljs-function">call</span>(badJSON, <span class="hljs-string">'name'</span>); <span class="hljs-comment">// true</span></code></pre>
<p>예를 들어 위와 같이 악의적인 클라이언트가 builtin 메서드를 감춘 형태의 JSON을 보내는 경우, 객체에서 직접 메서드를 사용해 처리한다면 에러를 발생시킬 수 있습니다.</p>
<p>이런 이유로 no-prototype-builtins 규칙은 builtin 메서드 사용시 Object.prototype을 활용하도록 권합니다.</p>
</li>
</ol>
<h2>2. no-return-await</h2>
<p><a href="https://eslint.org/docs/rules/no-return-await">ESLint: no-return-await</a></p>
<p>이 규칙은 <code>async function</code> 내부에서 <code>return await</code>을 하지 않도록 하는 규칙입니다. 예를 들어 다음과 같은 경우 입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">getSomePromise</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">/* ... */</span>
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">asyncCall</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title hljs-function">getSomePromise</span>(); <span class="hljs-comment">// no-return-await 규칙에 걸린다.</span>
}</code></pre>
<p>이 규칙에서 <code>return await</code>을 잡아내는 이유는 async 키워드를 붙힌 function은 promise를 반환하기 때문입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">getSomePromise</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">/* ... */</span>
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">asyncCall</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// ...</span>

  <span class="hljs-comment">// (1) promise가 fulfill 되기를 기다렸다가, 값을 반환함</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title hljs-function">getSomePromise</span>();
  <span class="hljs-comment">// (2) async로 선언되었기 때문에 promise가 반환됨</span>
}

<span class="hljs-comment">/* 어디선가 asyncCall()을 호출할 때, */</span>.
<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// (3) promise가 fulfill 되기를 기다렸다가, 값을 반환함</span>
<span class="hljs-keyword">const</span> value = <span class="hljs-keyword">await</span> <span class="hljs-title hljs-function">asynCall</span>();

<span class="hljs-comment">// ...</span></code></pre>
<p>위 코드를 보면 (1), (3)이 중복되는 과정이라는 것을 알 수 있습니다.</p>
<ul>
<li>(1). async function 내부에서 await으로 promise가 fulfill 되기를 기다린 후</li>
<li>(2). fulfill된 값을 다시 promise로 감싸서 반환하고,</li>
<li>(3). asynCall()을 사용하는 곳에서 await으로 promise가 fulfill 되기를 기다리게 됩니다.</li>
</ul>
<p>비록 성능상에 큰 차이가 발생하지는 않지만 불필요한 작업이기 때문에 ESLint에서 걸러낼수 있는 규칙으로 제공하고 있습니다.</p>
<p>하지만 이 규칙에서도 return await을 허용하는 경우가 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">getSomePromise</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">/* ... */</span>
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">asyncCall</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title hljs-function">getSomePromise</span>();
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-comment">// ...</span>
  }
}</code></pre>
<p>바로 위와 같이 <code>try catch</code>로 return await을 감쌀 때입니다. await 뒤에 온 promise가 reject될 경우 Error를 throw 합니다. 그리고 그 에러 처리를 try catch를 통해 async 함수 내부에서 처리할 수 있습니다. 때문에 no-return-await 규칙을 사용하더라도 try catch로 감싼 경우는 통과하게 됩니다.</p>
<h2>3. comma-dangle</h2>
<p><a href="https://eslint.org/docs/rules/comma-dangle">ESLint: comma-dangle</a></p>
<p>이 규칙은 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Trailing_commas">trailing-comma</a>를 사용하도록 설정할 수 있는 규칙입니다. trailing-comma는 object나 array의 값, function의 매개변수 등을 나타낼 때 마지막에 콤마(,)를 하나 더 추가하는 규칙입니다.</p>
<p>예를 들어 다음과 같이 마지막 프로퍼티나 매개변수 뒤에 콤마(,)를 하나 더 추가하는 것을 말합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = {
  <span class="hljs-attr">foo</span>: <span class="hljs-string">'foo'</span>,
  <span class="hljs-attr">bar</span>: <span class="hljs-string">'bar'</span>, <span class="hljs-comment">// 콤마(,)가 추가 되어있다.</span>
}

<span class="hljs-comment">// 매개변수 마지막에 콤마(,)가 추가되어 있다.</span>
<span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">func</span>(<span class="hljs-params">a, b, </span>) {} </code></pre>
<p>처음에 규칙을 사용하기만 할 때는 단순한 스타일을 일치시키기 위한 용도인 줄만 알았습니다. 하지만 trailing-comma를 사용함으로써 얻는 장점이 있습니다.</p>
<p>여러 줄로 이루어진 값을 수정할 때, 삭제/추가해야 할 줄만 수정할 수 있다는 점 입니다. 이 장점 덕분에 형상관리 툴에서 수정사항을 비교하기 쉽습니다.</p>
<ul>
<li>
<p>trailing-comma를 사용하지 않았을 때</p>
<p><img src="./assets/comma-dangle-1.png" alt="comma-dangle-1"></p>
</li>
<li>
<p>trailing-comma를 사용했을 때</p>
<p><img src="./assets/comma-dangle-2.png" alt="comma-dangle-2"></p>
</li>
</ul>
<p>위와 같이 형상관리 툴 (의 diff 기능) 이용시, trailing-comma를 사용하지 않는다면 콤마가 추가된 라인까지 수정으로 표시됩니다.</p>
<p>trailing-comma를 사용시 추가, 삭제가 된 라인만 표시되게 되어 더 깔끔한 비교 결과를 확인할 수 있습니다.</p>
<ul>
<li>IE6/7/9 Quirks mode 에서는 trailing-comma 가 문제를 일으킬 수 있습니다.</li>
</ul>

    </article>
  </body>
</html>
