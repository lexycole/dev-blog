
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    
    <link rel="stylesheet" href="/dev-blog/highlight/default.min.css">
  </head>
  <body>
    <article>
      <h1>Functional JavaScript First Steps</h1>
<blockquote>
<p><a href="https://frontendmasters.com/courses/functional-first-steps">FrontEnd Masters: Functional JavaScript First Steps</a> 수강후 정리한 글.</p>
</blockquote>
<h2>What is Functional Programming</h2>
<ul>
<li>프로그래밍 패러다임</li>
</ul>
<h3>Programming Paradigms</h3>
<ul>
<li>Imperative
<ul>
<li>명령의 연속</li>
</ul>
</li>
<li>Object-Oriented
<ul>
<li>자신의 상태를 가진 객체들과 객체간에 메시지로 사호작용하는 형태로 구성</li>
</ul>
</li>
<li>Declarative</li>
<li>선언형으로 구성</li>
<li>어떻게 보다는 무엇에 집중</li>
</ul>
<h3>Pure Function</h3>
<ul>
<li>블랙박스로 생각할 수 있음</li>
<li>동일 입력에 따라 동일 출력을 보장</li>
<li>사이드 이펙트가 없는 함수</li>
<li>사이드 이펙트
<ul>
<li>입력/출력을 제외한 다른 영역과 영향을 미치는 행위</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// Not pure</span>
<span class="hljs-keyword">let</span> name = <span class="hljs-string">'Alonzo'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">greet</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">${name}</span>!`</span>);
}

<span class="hljs-title hljs-function">greet</span>(); <span class="hljs-comment">// Hello Alonzo!</span>
name = <span class="hljs-string">'Alan'</span>;
<span class="hljs-title hljs-function">greet</span>(); <span class="hljs-comment">// Alonzo, Alan</span>
<span class="hljs-comment">// 입력이 같지만 다른 결과</span>

<span class="hljs-comment">// Pure</span>
<span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">greet</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">${name}</span>!`</span>;
}
<span class="hljs-title hljs-function">greet</span>(<span class="hljs-string">'Alonzo'</span>); <span class="hljs-comment">// "Hello Alonzo!"</span>
<span class="hljs-title hljs-function">greet</span>(<span class="hljs-string">'Alan'</span>); <span class="hljs-comment">// "Hello Alan!"</span></code></pre>
<h3>Why functional programming</h3>
<ul>
<li>순수 함수를 통해 결과가 예측 가능해져 안전함</li>
<li>테스트와 디버깅이 쉬움</li>
<li>함수형이 적절하지 않은 경우도 있음</li>
</ul>
<h3>Why functional JavaScript</h3>
<ul>
<li>OOP JS 의 어려운 부분: prototype, this...</li>
</ul>
<h3>Side Effect</h3>
<ul>
<li>함수 내에서 외부 데이터를 수정하는 행위</li>
<li>인자를 자외하고 외부에서 데이터를 가져오는 행위</li>
<li>함수 내에서 외부 데이터를 업데이트 하는 행위</li>
</ul>
<p>-> Functional: 사이드 이펙트 대신 인자로 주어진 데이터를 복사해서 새로운 데이터로 반환</p>
<h2>Recursion</h2>
<ul>
<li>
<p>Iteration</p>
<ul>
<li>Imperative</li>
<li>looping</li>
<li>stateful</li>
</ul>
</li>
<li>
<p>Recursion</p>
<ul>
<li>functional</li>
<li>self-referential</li>
<li>stateless</li>
</ul>
</li>
<li>
<p>iteration:</p>
</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">sum</span> (numbers) {
  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; numbers.<span class="hljs-property">length</span>; i++) {
    total += numbers[i];
  }
  <span class="hljs-keyword">return</span> total;
}</code></pre>
<ul>
<li>recursion:</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">sum</span>(<span class="hljs-params">numbers</span>) {
  <span class="hljs-keyword">if</span> (numbers.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>){
    <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">0</span>];
  }
  <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">0</span>] + <span class="hljs-title hljs-function">sum</span>(numbers.<span class="hljs-title hljs-function">slice</span>(<span class="hljs-number">1</span>));
}</code></pre>
<h3>Performance: iteration vs recursion</h3>
<ul>
<li>call stack</li>
<li>같은 입력에 대해 동일한 처리를 여러번 함 => 메모이제이션으로 해결</li>
</ul>
<h2>Higher-order functions</h2>
<ul>
<li>함수를 입력 또는 출력으로 가지는 함수를 지칭함</li>
</ul>
<h2>Closure</h2>
<h3>Functions can define functions</h3>
<ul>
<li>내부 함수를 반환함으로써 스코프를 기억하게 할 수 있다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">makeAdjectifier</span>(<span class="hljs-params">adjective</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">noun</span>) {
    <span class="hljs-keyword">return</span> adjective + <span class="hljs-string">" "</span> + noun;
  }
}

<span class="hljs-keyword">const</span> coolify = <span class="hljs-title hljs-function">makeAdjectifier</span>(<span class="hljs-string">"cool"</span>);
<span class="hljs-title hljs-function">coolify</span>(<span class="hljs-string">"workshop"</span>); <span class="hljs-comment">// "cool workshop";</span>
</code></pre>
<h2>Currying</h2>
<h2>Function composition</h2>
<ul>
<li>간단한 함수들로 복잡한 함수를 생성</li>
</ul>
<h3>pipeline</h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">pipeline</span>(<span class="hljs-params">...functions</span>) {
  <span class="hljs-keyword">const</span> <span class="hljs-title hljs-function">pipe</span> = (<span class="hljs-params">arg</span>) => functions.<span class="hljs-title hljs-function">reduce</span>(<span class="hljs-function">(<span class="hljs-params">ret, func</span>) =></span> <span class="hljs-title hljs-function">func</span>(ret), arg);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">input</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title hljs-function">pipe</span>(input);
  };
}


<span class="hljs-keyword">const</span> somePipe = <span class="hljs-title hljs-function">pipeline</span>(func1, func2, ...);
<span class="hljs-keyword">const</span> output = <span class="hljs-title hljs-function">somePipe</span>(input);</code></pre>
<h3>Immutability</h3>
<ul>
<li>
<p>Mutation 을 피하기 위해서 데이터를 카피해 새로운 데이터를 생성해야함 -> 효율적이지 않음 -> Immutable Data Structure 를 사용</p>
</li>
<li>
<p>Immutable Data Structure</p>
<ul>
<li>트리형태로 구성된 데이터</li>
<li>실제 카피가 필요한 데이터만 카피</li>
<li>https://github.com/immutable-js/immutable-js</li>
<li>https://immerjs.github.io/immer/</li>
</ul>
</li>
</ul>

    </article>
  </body>
</html>
