<h1>Functional JavaScript First Steps</h1>
<blockquote>
<p><a href="https://frontendmasters.com/courses/functional-first-steps"></a> 수강후 정리한 글.</p>
</blockquote>
<h2>What is Functional Programming</h2>
<ul>
<li>프로그래밍 패러다임</li>
</ul>
<h3>Programming Paradigms</h3>
<ul>
<li>Imperative
<ul>
<li>명령의 연속</li>
</ul>
</li>
<li>Object-Oriented
<ul>
<li>자신의 상태를 가진 객체들과 객체간에 메시지로 사호작용하는 형태로 구성</li>
</ul>
</li>
<li>Declarative</li>
<li>선언형으로 구성</li>
<li>어떻게 보다는 무엇에 집중</li>
</ul>
<h3>Pure Function</h3>
<ul>
<li>블랙박스로 생각할 수 있음</li>
<li>동일 입력에 따라 동일 출력을 보장</li>
<li>사이드 이펙트가 없는 함수</li>
<li>사이드 이펙트
<ul>
<li>입력/출력을 제외한 다른 영역과 영향을 미치는 행위</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// Not pure
let name = 'Alonzo';

function greet() {
  console.log(`Hello, ${name}!`);
}

greet(); // Hello Alonzo!
name = 'Alan';
greet(); // Alonzo, Alan
// 입력이 같지만 다른 결과

// Pure
function greet(name) {
  return `Hello, ${name}!`;
}
greet('Alonzo'); // "Hello Alonzo!"
greet('Alan'); // "Hello Alan!"
</code></pre>
<h3>Why functional programming</h3>
<ul>
<li>순수 함수를 통해 결과가 예측 가능해져 안전함</li>
<li>테스트와 디버깅이 쉬움</li>
<li>함수형이 적절하지 않은 경우도 있음</li>
</ul>
<h3>Why functional JavaScript</h3>
<ul>
<li>OOP JS 의 어려운 부분: prototype, this...</li>
</ul>
<h3>Side Effect</h3>
<ul>
<li>함수 내에서 외부 데이터를 수정하는 행위</li>
<li>인자를 자외하고 외부에서 데이터를 가져오는 행위</li>
<li>함수 내에서 외부 데이터를 업데이트 하는 행위</li>
</ul>
<p>-> Functional: 사이드 이펙트 대신 인자로 주어진 데이터를 복사해서 새로운 데이터로 반환</p>
<h2>Recursion</h2>
<ul>
<li>
<p>Iteration</p>
<ul>
<li>Imperative</li>
<li>looping</li>
<li>stateful</li>
</ul>
</li>
<li>
<p>Recursion</p>
<ul>
<li>functional</li>
<li>self-referential</li>
<li>stateless</li>
</ul>
</li>
<li>
<p>iteration:</p>
</li>
</ul>
<pre><code class="language-js">function sum (numbers) {
  let total = 0;
  for (let i = 0; i &#x3C; numbers.length; i++) {
    total += numbers[i];
  }
  return total;
}
</code></pre>
<ul>
<li>recursion:</li>
</ul>
<pre><code class="language-js">function sum(numbers) {
  if (numbers.length === 1){
    return numbers[0];
  }
  return numbers[0] + sum(numbers.slice(1));
}
</code></pre>
<h3>Performance: iteration vs recursion</h3>
<ul>
<li>call stack</li>
<li>같은 입력에 대해 동일한 처리를 여러번 함 => 메모이제이션으로 해결</li>
</ul>
<h2>Higher-order functions</h2>
<ul>
<li>함수를 입력 또는 출력으로 가지는 함수를 지칭함</li>
</ul>
<h2>Closure</h2>
<h3>Functions can define functions</h3>
<ul>
<li>내부 함수를 반환함으로써 스코프를 기억하게 할 수 있다.</li>
</ul>
<pre><code class="language-js">function makeAdjectifier(adjective) {
  return function (noun) {
    return adjective + " " + noun;
  }
}

const coolify = makeAdjectifier("cool");
coolify("workshop"); // "cool workshop";

</code></pre>
<h2>Currying</h2>
<h2>Function composition</h2>
<ul>
<li>간단한 함수들로 복잡한 함수를 생성</li>
</ul>
<h3>pipeline</h3>
<pre><code class="language-js">function pipeline(...functions) {
  const pipe = (arg) => functions.reduce((ret, func) => func(ret), arg);
  return function(input) {
    return pipe(input);
  };
}


const somePipe = pipeline(func1, func2, ...);
const output = somePipe(input);
</code></pre>
<h3>Immutability</h3>
<ul>
<li>
<p>Mutation 을 피하기 위해서 데이터를 카피해 새로운 데이터를 생성해야함 -> 효율적이지 않음 -> Immutable Data Structure 를 사용</p>
</li>
<li>
<p>Immutable Data Structure</p>
<ul>
<li>트리형태로 구성된 데이터</li>
<li>실제 카피가 필요한 데이터만 카피</li>
<li>https://github.com/immutable-js/immutable-js</li>
<li>https://immerjs.github.io/immer/</li>
</ul>
</li>
</ul>
